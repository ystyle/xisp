;; ======================================
;; 解构绑定 (Destructuring) 示例
;; ======================================
;; 解构绑定是 let 的一种特殊形式，可以将复杂的数据结构
;; 解构并绑定到变量

;; ==================== 1. 基本列表解构 ====================
;; 将列表元素绑定到变量
(let [(x y z) (quote (1 2 3))]
  (list x y z))
;; => (1.000000 2.000000 3.000000)

;; ==================== 2. 嵌套列表解构 ====================
;; 解构嵌套的数据结构
(let [((a b) (c d)) (quote ((1 2) (3 4)))]
  (list a b c d))
;; => (1.000000 2.000000 3.000000 4.000000)

;; ==================== 3. 混合解构 ====================
;; 同时解构多个列表
(let [(x y) (quote (1 2))
      (a b) (quote (3 4))]
  (list x y a b))
;; => (1.000000 2.000000 3.000000 4.000000)

;; ==================== 4. Rest 参数解构 ====================
;; 使用 & 绑定剩余元素
(let [(x y & rest) (quote (1 2 3 4 5))]
  (list x y rest))
;; => (1.000000 2.000000 (3.000000 4.000000 5.000000))

;; ==================== 5. 向量解构 ====================
;; 解构向量字面量
(let [[x y z] [1 2 3]]
  (list x y z))
;; => (1.000000 2.000000 3.000000)

;; ==================== 6. 在函数参数中使用解构 ====================
;; 定义函数时使用解构参数
(define (get-first-pair [(x y) _])
  (list x y))

(get-first-pair (quote (1 2 3)))
;; => (1.000000 2.000000)

;; ==================== 7. 解构与模式匹配结合 ====================
;; 在 match 中使用解构
(define (describe-list lst)
  (match lst
    () "empty list"
    (x) "single element"
    (x y) "two elements"
    (x y & rest) (str "first: " x ", second: " y ", has more")
    _ "other"))

(describe-list (quote (1 2 3 4)))
;; => "first: 1.000000, second: 2.000000, has more"

;; ==================== 8. 复杂数据结构解构 ====================
;; 解构复杂嵌套结构
(let [(person (name age) address (city country))
      (quote (Alice ("Alice" 25) (Beijing "China")))]
  (str name " is " age " years old, lives in " city ", " country)
;; => "Alice is 25.000000 years old, lives in Beijing, China"
